import streamlit as st
import pandas as pd
import numpy as np
from scipy.interpolate import CubicSpline
import plotly.express as px
import io
from openpyxl import load_workbook
from openpyxl.styles import PatternFill

# --- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏ ---
st.set_page_config(page_title="Media Split Optimizer", layout="wide")
st.title("üéØ –°—É—á–∞—Å–Ω–∏–π –º–µ–¥—ñ–∞-—Å–ø–ª—ñ—Ç –¢–ë + Digital")

# --- Sidebar –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ ---
with st.sidebar:
    st.header("–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–∞–º–ø–∞–Ω—ñ—ó")
    budget = st.slider("–ó–∞–≥–∞–ª—å–Ω–∏–π –±—é–¥–∂–µ—Ç (‚Ç¥)", 100_000, 50_000_000, 5_000_000, step=100_000, format="%d ‚Ç¥")
    flight_weeks = st.slider("–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Ñ–ª–∞–π—Ç—É (—Ç–∏–∂–Ω—ñ)", 1, 30, 4)
    audience_size = st.number_input("–†–æ–∑–º—ñ—Ä –∞—É–¥–∏—Ç–æ—Ä—ñ—ó Digital (—Ç–∏—Å.)", min_value=1.0, value=1000.0)
    tv_cost_per_trp = st.number_input("–í–∞—Ä—Ç—ñ—Å—Ç—å 1 TRP –¢–ë (‚Ç¥)", value=500.0)
    dig_cost_per_imp = st.number_input("–í–∞—Ä—Ç—ñ—Å—Ç—å 1 —Ç–∏—Å. —ñ–º–ø—Ä–µ—Å—ñ–π Digital (‚Ç¥)", value=5.0)
    tv_weekly_clutter = st.number_input("–ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∏–π —Ç–∏—Å–∫ –¢–ë (–¢–†–ü/—Ç–∏–∂–¥–µ–Ω—å)", value=150.0)
    dig_weekly_clutter = st.number_input("–ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∏–π —Ç–∏—Å–∫ Digital (TRP/—Ç–∏–∂–¥–µ–Ω—å)", value=300.0)
    split_step_percent = st.selectbox("–ö—Ä–æ–∫ —Å–ø–ª—ñ—Ç—É (%)", [5, 10, 15, 20])
    n_options = st.slider("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ —Å–ø–ª—ñ—Ç—ñ–≤", 5, 15, 10)

# --- –í–≤–µ–¥–µ–Ω–Ω—è TRP ‚Üí Reach –¥–ª—è –¢–ë —ñ Digital ---
with st.expander("TRP ‚Üí Reach –¢–ë (5 —Ç–æ—á–æ–∫)"):
    tv_trp_points, tv_reach_points = [], []
    for i in range(5):
        col1, col2 = st.columns(2)
        trp = col1.slider(f"TRP –¢–ë, —Ç–æ—á–∫–∞ {i+1}", 0.0, 500.0, float(i*50+50))
        reach = col2.slider(f"Reach_TV %, —Ç–æ—á–∫–∞ {i+1}", 0.0, 100.0, float(i*10+20))
        tv_trp_points.append(trp)
        tv_reach_points.append(reach/100)

with st.expander("TRP ‚Üí Reach Digital (5 —Ç–æ—á–æ–∫)"):
    dig_trp_points, dig_reach_points = [], []
    for i in range(5):
        col1, col2 = st.columns(2)
        trp = col1.slider(f"TRP Digital, —Ç–æ—á–∫–∞ {i+1}", 0.0, 500.0, float(i*10+10))
        reach = col2.slider(f"Reach_Digital %, —Ç–æ—á–∫–∞ {i+1}", 0.0, 100.0, float(i*5+10))
        dig_trp_points.append(trp)
        dig_reach_points.append(reach/100)

# --- –Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è ---
tv_spline = CubicSpline(tv_trp_points, tv_reach_points)
dig_spline = CubicSpline(dig_trp_points, dig_reach_points)

# --- –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ —Å–ø–ª—ñ—Ç—ñ–≤ –∑ –æ–±—Ä–∞–Ω–∏–º –∫—Ä–æ–∫–æ–º ---
split_step = split_step_percent / 100.0
split_values = np.arange(split_step, 1.0, split_step)
split_values = split_values[:n_options]  # –æ–±–º–µ–∂–µ–Ω–Ω—è –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –æ–ø—Ü—ñ–π
results = []
budget_warning = False
min_needed_budget = 0

for i, split in enumerate(split_values, start=1):
    tv_budget = budget * split
    dig_budget = budget * (1 - split)
    
    tv_trp = tv_budget / tv_cost_per_trp
    dig_imp = dig_budget / dig_cost_per_imp
    dig_trp = dig_imp / audience_size * 100
    
    tv_reach = float(np.clip(tv_spline(tv_trp), 0, 0.82))
    dig_reach = float(np.clip(dig_spline(dig_trp), 0, 0.99))
    cross_reach = tv_reach + dig_reach - tv_reach*dig_reach
    
    tv_weekly = tv_trp / flight_weeks
    dig_weekly = dig_trp / flight_weeks
    
    overall_ok = (tv_weekly >= tv_weekly_clutter) & (dig_weekly >= dig_weekly_clutter)
    if not overall_ok:
        budget_warning = True
        min_tv_budget = tv_weekly_clutter * flight_weeks * tv_cost_per_trp
        min_dig_budget = dig_weekly_clutter * flight_weeks * dig_cost_per_imp * audience_size / 100
        min_needed_budget = max(min_needed_budget, min_tv_budget + min_dig_budget)
    
    cpr = (tv_budget + dig_budget) / (cross_reach*100)
    cpt_dig = dig_budget / dig_trp
    
    results.append({
        "–û–ø—Ü—ñ—è": f"–û–ø—Ü—ñ—è {i}",
        "–°–ø–ª—ñ—Ç –¢–ë": f"{split*100:.0f}%",
        "–ë—é–¥–∂–µ—Ç –¢–ë": int(tv_budget),
        "–ë—é–¥–∂–µ—Ç Digital": int(dig_budget),
        "TRP_TV": round(tv_trp,1),
        "TRP_Digital": round(dig_trp,1),
        "Imp_Digital": round(dig_imp,1),
        "Reach_TV %": round(tv_reach*100,1),
        "Reach_Digital %": round(dig_reach*100,1),
        "Cross_Reach %": round(cross_reach*100,1),
        "–¢–∏—Å–∫ –¢–ë/—Ç–∏–∂–¥": round(tv_weekly,1),
        "–¢–∏—Å–∫ Digital/—Ç–∏–∂–¥": round(dig_weekly,1),
        "CPR": round(cpr,2),
        "CPT_Digital": round(cpt_dig,2),
        "–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π": overall_ok
    })

df = pd.DataFrame(results)
df['–î–æ–ª—è –¢–ë %'] = df['–ë—é–¥–∂–µ—Ç –¢–ë'] / (df['–ë—é–¥–∂–µ—Ç –¢–ë'] + df['–ë—é–¥–∂–µ—Ç Digital']) * 100
df['–î–æ–ª—è Digital %'] = df['–ë—é–¥–∂–µ—Ç Digital'] / (df['–ë—é–¥–∂–µ—Ç –¢–ë'] + df['–ë—é–¥–∂–µ—Ç Digital']) * 100

# --- –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è ---
if budget_warning:
    st.warning(f"‚ö†Ô∏è –î–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–≥–æ —Ç–∏—Å–∫—É –ø–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ {int(min_needed_budget):,} ‚Ç¥. "
               "–ú–æ–∂–Ω–∞ –∑–±—ñ–ª—å—à–∏—Ç–∏ –±—é–¥–∂–µ—Ç –∞–±–æ —Å–∫–æ—Ä–æ—Ç–∏—Ç–∏ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Ñ–ª–∞–π—Ç—É.")

best_idx = df[df["–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π"]]["CPR"].idxmin() if df[df["–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π"]].shape[0]>0 else df["CPR"].idxmin()
best_option = df.loc[best_idx]

# --- –ö–∞—Ä—Ç–∫–∏ –∑ –º–µ—Ç—Ä–∏–∫–∞–º–∏ ---
st.subheader("üèÜ –ù–∞–π–∫—Ä–∞—â–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç —Å–ø–ª—ñ—Ç—É")
col1, col2, col3 = st.columns(3)
col1.metric("–ù–∞–π–Ω–∏–∂—á–∏–π CPR", f"{best_option['CPR']:.2f}")
col2.metric("Cross Reach %", f"{best_option['Cross_Reach %']:.1f}%")
col3.metric("TRP Digital", f"{best_option['TRP_Digital']:.1f}")

# --- Stack bar plot –±—é–¥–∂–µ—Ç—É ---
st.subheader("üìä –î–æ–ª—ñ –±—é–¥–∂–µ—Ç—É –ø–æ –º–µ–¥—ñ–∞")
df_budget_plot = df.melt(id_vars=["–û–ø—Ü—ñ—è"], value_vars=["–î–æ–ª—è –¢–ë %", "–î–æ–ª—è Digital %"],
                         var_name="–ú–µ–¥—ñ–∞", value_name="–î–æ–ª—è %")
df_budget_plot["–ú–µ–¥—ñ–∞"] = df_budget_plot["–ú–µ–¥—ñ–∞"].replace({"–î–æ–ª—è –¢–ë %": "–¢–ë", "–î–æ–ª—è Digital %": "Digital"})
color_map = {"–¢–ë": "black", "Digital": "red"}

fig_budget = px.bar(df_budget_plot, x="–û–ø—Ü—ñ—è", y="–î–æ–ª—è %", color="–ú–µ–¥—ñ–∞", text="–î–æ–ª—è %",
                    title="–î–æ–ª—ñ –±—é–¥–∂–µ—Ç—É –ø–æ –º–µ–¥—ñ–∞ (stacked)", color_discrete_map=color_map)
fig_budget.update_yaxes(title_text="–î–æ–ª—è –±—é–¥–∂–µ—Ç—É (%)")
fig_budget.update_traces(texttemplate="%{text:.1f}%", textposition="inside")
st.plotly_chart(fig_budget, use_container_width=True)

# --- –õ—ñ–Ω—ñ–π–Ω–∏–π –≥—Ä–∞—Ñ—ñ–∫ –æ—Ö–æ–ø–ª–µ–Ω–Ω—è ---
st.subheader("üìà –û—Ö–æ–ø–ª–µ–Ω–Ω—è –ø–æ –≤—Å—ñ—Ö –æ–ø—Ü—ñ—è—Ö")
fig_reach = px.line(df, x="–û–ø—Ü—ñ—è", y=["Reach_TV %","Reach_Digital %","Cross_Reach %"],
                    markers=True, title="Reach TV / Digital / Cross")
st.plotly_chart(fig_reach, use_container_width=True)

# --- –í–∏–≤–µ–¥–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ ---
st.subheader("üìã –í–∞—Ä—ñ–∞–Ω—Ç–∏ —Å–ø–ª—ñ—Ç—ñ–≤ —Ç–∞ –∫–ª—é—á–æ–≤—ñ –ø–æ–∫–∞–∑–Ω–∏–∫–∏")
def highlight_rows(row):
    if row['–û–ø—Ü—ñ—è'] == best_option['–û–ø—Ü—ñ—è']:
        return ['background-color: lightblue']*len(row)
    elif row['–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π']:
        return ['background-color: lightgreen']*len(row)
    else:
        return ['background-color: salmon']*len(row)

st.dataframe(df.style.apply(highlight_rows, axis=1))

# --- Excel download ---
st.subheader("‚¨áÔ∏è –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è Excel –∑ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è–º –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ CPR")
output = io.BytesIO()
with pd.ExcelWriter(output, engine="openpyxl") as writer:
    df.to_excel(writer, index=False, sheet_name="Splits")

output.seek(0)
wb = load_workbook(output)
ws = wb["Splits"]

# –í–∏–¥—ñ–ª–µ–Ω–Ω—è –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ CPR
cpr_col = None
for i, cell in enumerate(ws[1], start=1):
    if cell.value == "CPR":
        cpr_col = i
        break

if cpr_col:
    min_cpr = min(df["CPR"])
    fill = PatternFill(start_color="00FFFF00", end_color="00FFFF00", fill_type="solid")
    for row in range(2, ws.max_row+1):
        if ws.cell(row=row, column=cpr_col).value == min_cpr:
            for col in range(1, ws.max_column+1):
                ws.cell(row=row, column=col).fill = fill

output_final = io.BytesIO()
wb.save(output_final)
output_final.seek(0)

st.download_button(
    label="–°–∫–∞—á–∞—Ç–∏ Excel (–∑ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è–º –Ω–∞–π–∫—Ä–∞—â–æ–≥–æ CPR)",
    data=output_final,
    file_name="media_split_highlighted.xlsx",
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)


