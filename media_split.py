import streamlit as st
import pandas as pd
import numpy as np
from scipy.interpolate import CubicSpline
import plotly.express as px
import io
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows

st.set_page_config(page_title="Media Split Dashboard", layout="wide")
st.title("üéØ Media Split Dashboard ‚Äî –¢–ë + Digital")

# --- Sidebar ---
with st.sidebar:
    st.header("–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–∞–º–ø–∞–Ω—ñ—ó")
    budget = st.slider("–ë—é–¥–∂–µ—Ç (‚Ç¥)", 100_000, 50_000_000, 5_000_000, step=100_000)
    flight_weeks = st.slider("–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Ñ–ª–∞–π—Ç—É (—Ç–∏–∂–Ω—ñ)", 1, 30, 4)
    audience_size = st.number_input("–ê—É–¥–∏—Ç–æ—Ä—ñ—è Digital (—Ç–∏—Å.)", 1000.0)
    tv_cost_per_trp = st.number_input("–í–∞—Ä—Ç—ñ—Å—Ç—å 1 TRP –¢–ë (‚Ç¥)", 500.0)
    dig_cost_per_imp = st.number_input("–í–∞—Ä—Ç—ñ—Å—Ç—å 1 —Ç–∏—Å. —ñ–º–ø—Ä. Digital (‚Ç¥)", 5.0)
    tv_weekly_clutter = st.number_input("–¢–∏—Å–∫ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç—ñ–≤ –¢–ë (–¢–†–ü/—Ç–∏–∂–¥.)", 150.0)
    dig_weekly_clutter = st.number_input("–¢–∏—Å–∫ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç—ñ–≤ Digital (TRP/—Ç–∏–∂–¥.)", 300.0)
    split_step_percent = st.selectbox("–ö—Ä–æ–∫ —Å–ø–ª—ñ—Ç—É (%)", [5, 10, 15, 20])
    n_options = st.slider("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ —Å–ø–ª—ñ—Ç—ñ–≤", 5, 15, 10)

# --- –í–≤–µ–¥–µ–Ω–Ω—è 5 —Ç–æ—á–æ–∫ TRP‚ÜíReach –¥–ª—è –¢–ë —ñ Digital ---
def input_points(media_name):
    st.subheader(f"{media_name} ‚Äî –í–≤–µ–¥—ñ—Ç—å 5 —Ç–æ—á–æ–∫ TRP ‚Üí Reach (%)")
    trp_points = []
    reach_points = []
    for i in range(5):
        cols = st.columns(2)
        trp = cols[0].number_input(f"{media_name} TRP —Ç–æ—á–∫–∞ {i+1}", min_value=0.0, max_value=1000.0, value=50.0*(i+1))
        reach = cols[1].number_input(f"{media_name} Reach % —Ç–æ—á–∫–∞ {i+1}", min_value=0.0, max_value=100.0, value=20.0*(i+1))
        trp_points.append(trp)
        reach_points.append(reach/100)
    return CubicSpline(trp_points, reach_points)

tv_spline = input_points("–¢–ë")
dig_spline = input_points("Digital")

# --- –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–ø–ª—ñ—Ç—ñ–≤ ---
split_step = split_step_percent / 100.0
split_values = np.arange(split_step, 1.0, split_step)[:n_options]
results = []
budget_warning = False
min_needed_budget = 0

for i, split in enumerate(split_values, start=1):
    tv_budget = budget * split
    dig_budget = budget * (1 - split)
    tv_trp = tv_budget / tv_cost_per_trp
    dig_imp = dig_budget / dig_cost_per_imp
    dig_trp = dig_imp / audience_size * 100

    tv_reach = float(np.clip(tv_spline(tv_trp), 0, 0.82))
    dig_reach = float(np.clip(dig_spline(dig_trp), 0, 0.99))
    cross_reach = tv_reach + dig_reach - tv_reach*dig_reach

    tv_weekly = tv_trp / flight_weeks
    dig_weekly = dig_trp / flight_weeks

    overall_ok = (tv_weekly >= tv_weekly_clutter) & (dig_weekly >= dig_weekly_clutter)
    if not overall_ok:
        budget_warning = True
        min_tv_budget = tv_weekly_clutter * flight_weeks * tv_cost_per_trp
        min_dig_budget = dig_weekly_clutter * flight_weeks * dig_cost_per_imp * audience_size / 100
        min_needed_budget = max(min_needed_budget, min_tv_budget + min_dig_budget)

    cpr = (tv_budget + dig_budget) / (cross_reach*100)
    cpt_dig = dig_budget / dig_trp

    results.append({
        "–û–ø—Ü—ñ—è": f"–û–ø—Ü—ñ—è {i}",
        "–°–ø–ª—ñ—Ç –¢–ë %": round(split*100,0),
        "–ë—é–¥–∂–µ—Ç –¢–ë": int(tv_budget),
        "–ë—é–¥–∂–µ—Ç Digital": int(dig_budget),
        "TRP_TV": round(tv_trp,1),
        "TRP_Digital": round(dig_trp,1),
        "Imp_Digital": round(dig_imp,1),
        "Reach_TV %": round(tv_reach*100,1),
        "Reach_Digital %": round(dig_reach*100,1),
        "Cross_Reach %": round(cross_reach*100,1),
        "–¢–∏—Å–∫ –¢–ë/—Ç–∏–∂–¥": round(tv_weekly,1),
        "–¢–∏—Å–∫ Digital/—Ç–∏–∂–¥": round(dig_weekly,1),
        "CPR": round(cpr,2),
        "CPT_Digital": round(cpt_dig,2),
        "–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π": overall_ok
    })

df = pd.DataFrame(results)
df['–î–æ–ª—è –¢–ë %'] = df['–ë—é–¥–∂–µ—Ç –¢–ë'] / (df['–ë—é–¥–∂–µ—Ç –¢–ë'] + df['–ë—é–¥–∂–µ—Ç Digital']) * 100
df['–î–æ–ª—è Digital %'] = df['–ë—é–¥–∂–µ—Ç Digital'] / (df['–ë—é–¥–∂–µ—Ç –¢–ë'] + df['–ë—é–¥–∂–µ—Ç Digital']) * 100

if budget_warning:
    st.warning(f"‚ö†Ô∏è –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –±—é–¥–∂–µ—Ç –¥–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–≥–æ —Ç–∏—Å–∫—É: {int(min_needed_budget):,} ‚Ç¥")

# --- –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞–π–∫—Ä–∞—â–æ—ó –æ–ø—Ü—ñ—ó ---
if df["–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π"].any():
    best_idx = df[df["–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π"]]["CPR"].idxmin()
else:
    best_idx = df["CPR"].idxmin()
best_option = df.loc[best_idx]

# --- KPI ---
st.subheader("üèÜ KPI")
col1, col2, col3 = st.columns(3)
col1.metric("–ù–∞–π–Ω–∏–∂—á–∏–π CPR", f"{best_option['CPR']:.2f}")
col2.metric("Cross Reach %", f"{best_option['Cross_Reach %']:.1f}%")
col3.metric("TRP Digital", f"{best_option['TRP_Digital']:.1f}")

# --- –ß–µ–∫–±–æ–∫—Å–∏ –¥–ª—è —Ç–æ—á–æ–∫ ---
show_tv_points = st.checkbox("–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ —Ç–æ—á–∫–∏ –¢–ë", value=True)
show_dig_points = st.checkbox("–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ —Ç–æ—á–∫–∏ Digital", value=True)

# --- –ì—Ä–∞—Ñ—ñ–∫ –¥–æ–ª–µ–π –±—é–¥–∂–µ—Ç—É ---
st.subheader("üìä –î–æ–ª—ñ –±—é–¥–∂–µ—Ç—É")
df_budget_plot = df.melt(id_vars=["–û–ø—Ü—ñ—è"], value_vars=["–î–æ–ª—è –¢–ë %", "–î–æ–ª—è Digital %"],
                         var_name="–ú–µ–¥—ñ–∞", value_name="–î–æ–ª—è %")
df_budget_plot["–ú–µ–¥—ñ–∞"] = df_budget_plot["–ú–µ–¥—ñ–∞"].replace({"–î–æ–ª—è –¢–ë %": "–¢–ë", "–î–æ–ª—è Digital %": "Digital"})
color_map = {"–¢–ë": "black", "Digital": "red"}
fig_budget = px.bar(df_budget_plot, x="–û–ø—Ü—ñ—è", y="–î–æ–ª—è %", color="–ú–µ–¥—ñ–∞", text="–î–æ–ª—è %",
                    title="–î–æ–ª—ñ –±—é–¥–∂–µ—Ç—É –ø–æ –º–µ–¥—ñ–∞ (stacked)", color_discrete_map=color_map)
fig_budget.update_yaxes(title_text="–î–æ–ª—è –±—é–¥–∂–µ—Ç—É (%)")
fig_budget.update_traces(texttemplate="%{text:.1f}%", textposition="inside")
st.plotly_chart(fig_budget, use_container_width=True)

# --- –ì—Ä–∞—Ñ—ñ–∫ –æ—Ö–æ–ø–ª–µ–Ω–Ω—è ---
st.subheader("üìà –û—Ö–æ–ø–ª–µ–Ω–Ω—è")
fig_reach = px.line(df, x="–û–ø—Ü—ñ—è", y=["Reach_TV %","Reach_Digital %","Cross_Reach %"],
                    markers=True, title="Reach TV / Digital / Cross")

if show_tv_points:
    tv_reach_pts = [tv_spline.y[i]*100 for i in range(5)]
    fig_reach.add_scatter(
        x=[f"–û–ø—Ü—ñ—è {i+1}" for i in range(5)],
        y=tv_reach_pts,
        mode="markers+text",
        name="–¢–ë —Ç–æ—á–∫–∏",
        marker=dict(symbol="circle", color="black", size=10),
        text=[f"{r:.1f}%" for r in tv_reach_pts],
        textposition="top center"
    )

if show_dig_points:
    dig_reach_pts = [dig_spline.y[i]*100 for i in range(5)]
    fig_reach.add_scatter(
        x=[f"–û–ø—Ü—ñ—è {i+1}" for i in range(5)],
        y=dig_reach_pts,
        mode="markers+text",
        name="Digital —Ç–æ—á–∫–∏",
        marker=dict(symbol="x", color="red", size=10),
        text=[f"{r:.1f}%" for r in dig_reach_pts],
        textposition="bottom center"
    )

st.plotly_chart(fig_reach, use_container_width=True)

# --- –¢–∞–±–ª–∏—Ü—è ---
st.subheader("üìã –í–∞—Ä—ñ–∞–Ω—Ç–∏ —Å–ø–ª—ñ—Ç—ñ–≤")
def highlight_rows(row):
    if row['–û–ø—Ü—ñ—è'] == best_option['–û–ø—Ü—ñ—è']:
        return ['background-color: lightblue']*len(row)
    elif row['–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π']:
        return ['background-color: lightgreen']*len(row)
    else:
        return ['background-color: salmon']*len(row)
st.dataframe(df.style.apply(highlight_rows, axis=1))

# --- Excel Export ---
def to_excel(df):
    output = io.BytesIO()
    wb = Workbook()
    ws = wb.active
    ws.title = "Results"
    for r in dataframe_to_rows(df, index=False, header=True):
        ws.append(r)
    wb.save(output)
    return output

st.download_button(
    label="‚¨áÔ∏è –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≤ Excel",
    data=to_excel(df),
    file_name="media_split_results.xlsx",
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)

